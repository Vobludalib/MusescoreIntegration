# Automatic Musescore plugin factory for external processing
By: Simon Libricky - [simonlibricky.com](www.simonlibricky.com)

As part of Charles University Individual Software Project

## TL;DR
This Python script exists to allow integration between external MXL processing and Musescore. Given a valid JSON file in the format described below, it will produce a barebones Musescore plugin QML file, that allows calling an external process on the command line and facilitate barebones reading of the score and writing to the score from MXL files generated by the process. Additionally, there is a wizard python script to guide you through creating the JSON file.

**As of right now only calling Python scripts is supported, as this is the same cross-platform. I have to plans to change this in the future.**

## Disclaimer
The QML code this script produces has no guarantees as to code quality or extendability. The code generated corresponds to what is easiest to automatically generate, but manual refactoring may be useful before using the code further. The visual layout of the plugin is barebones, and for a serious plugin I recommend manually changing the QML to look better. However, the difficult part of compiling command line arguments and calling external processes should be taken care of.

Inspiration in how to proceed was taken from: [ABC_ImpEx](https://github.com/mist13/ABC_ImpEx)

**THE PLUGINS GENERATED ARE WRITTEN FOR MUSESCORE 3.6** - I will hopefully update to 4.x after the Musescore plugin changes go through on their end and are properly documented.

## Using the Wizard
The wizard is a tool to help you through generating the JSON file that the factory then uses to produce your plugin.

To launch this wizard, just use:

```
python {path/to/wizard.py}
```

If you want finer control, you may opt to write the JSON manually or tweak the wizard's output:

## JSON Format
Ignore the // as comments
```
{ // Everything enclosed in a singular object
    "pluginName": String // Will become the string under which the plugin is seen as in MS
    "pluginVersion": String // Becomes the version number - subject to testing if there are limitations
    "readsScore": Bool // If the plugin needs to generate code to store the score into MXL
    "writesScore": Bool // If the plugin needs to generate code to load MXL into the score
    // If readsScore is true, the MS plugin will have requiresScore set to true
    "defaultSavePath": String // File to which the MS score should be stored to as MXL
    "executableScriptPath": String // Path of the script to execute
    "optionFields": [optionObjects] // See below
}
```

defaultSavePath works with relative file paths in a limited extent (limitation of MS plugins that I have partially sidestepped via Regex). A . at the beggining of the file path (i.e. the . in "<u>.</u>/myfolder/myfile.mxl") will be replaced with the current path of the directory in which the plugin is running. This may inform how you structure the directory. For more information, see the [How to package](#how-to-package) section.

There is no defaultLoadPath, as the behaviour for how to get the path of the 'return' MXL file from your external process is different. See the [Expectations of your processs](#expectations-of-your-process) section.

optionFields is a list of all the buttons/text fields etc. that will appear in the plugin. These are directly tied to which command line arguments are sent and their values. For more complex behaviour, you are likely to have to write some QML manually, but the format of how to apply your own changes to the framework of compiling command line arguments should be able to be gleaned from the code.

Currently supported:

- TextField - corresponds to [QML TextField](https://doc.qt.io/qt-5/qml-qtquick-controls-textfield.html)

    Format: { "type": "textField", "promptString": "xxx", "defaultValue": "xxx", "cla": "-xxx" }

- FileDialog - corresponds to [QML FileDialog](https://doc.qt.io/qt-5/qml-qtquick-dialogs-filedialog.html)

    Format: { "type": "fileDialog", "promptString": "xxx", "defaultValue": "./xxx/xxx", "cla": "-xxx" }

- ComboBox - corresponds to [QML ComboBox](https://doc.qt.io/qt-5/qml-qtquick-controls2-combobox.html)

    Format: { "type": "comboBox", "promptString": "xxx", "values": [ {"name": "DisplayName", "arg": "claName"}, {"name": "DisplayName2", "arg": "claName2"} ], "defaultValue": "xxx", "cla": "-xxx" }

    "values" here is a collection of the options to select from in the ComboBox. In the above example, this would mean a ComboBox with two options: DisplayName and DisplayName2. If we selected DisplayName2, then on the command line we would get -xxx "claName2".

- CheckBox - corresponds to [QML CheckBox](https://doc.qt.io/qt-5/qml-qtquick-controls2-checkbox.html)

    Format: Format: { "type": "checkBox", "promptString": "xxx", "defaultValue": true, "cla": "-xxx" }

    Here, if we set this CheckBox to false (i.e. it is not checked), then instead of getting -xxx "someValue" as a command line argument, we will instead just not put -xxx in the command line arguments.

## Expectations of your process
To make the factory consistent in the way it packages all the options for a command-line call, there are a few expectations of what that command-line call is in the form of.

If you want to load a score that your process creates (i.e. your plugin readsScore), then the path to this file is read from standard output of the process called on the command line. This is done with minimal processing, meaning that NOTHING ELSE can be printed to standard output. If you already have a process that prints some other things, it might be helpful for you to add an additional command-line argument to your process that changes the standard output behaviour to match this expectation while not affecting other usage of your process.

## How to package

This is not a be-all-end-all way of packaging, but it is the way that I have found to work most consistently. If you are using the wizard and selecting default save paths, this will work.

I recommend the following structure that you then zip and distribute to your users.

```
PluginFolder
 ┣ temp
 ┃ ┣ # Temp folder for holding the files
 ┃ ┗ # your script will generate/read from
 ┣ YourScript.py
 ┣ YourPlugin.qml
 ┗ AnyOtherDependencies.py
```

## TO DO

- [ ] Document how to make custom implementations work with compiling CLargs
- [x] Wizard to auto-generate the JSON file
- [ ] Fix bugs in Wizard with rejecting options and it still saving progress
- [ ] Finish example scripts to show how to use this